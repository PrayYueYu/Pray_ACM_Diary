# 月影戀-$Solution$

## 题意

有一个未知数 $h$，你需要通过不超过 $\lfloor \log_2 h\rfloor+3$ 次询问猜出这个数，每次询问可以提出两个数 $a,b$，会返回 $\gcd(a,h+b)$

## $Solution$

### $tips1$

看到 $\log_2 h$，首先想到需要在二进制下求解

### $tips2$

二进制下，$\gcd(1000000,1010)=10$，$\gcd(1000000,10100)=100$​

你发现了什么？

### $tips3$

$\gcd(2^{60}, a)$ 是否等于 $\gcd(2^{60},a+2^{60})$？

### 正解

由 $tip2$ 可以发现，$a=10...000_2$ 的时候( $a$ 为很大的 2 的幂)，$\gcd(a,b)=lowbit(b)$，即 $b$ 最低位为 $1$ ​的位置​

所以 $tip3$ 显然是正确的，因为高位 1 并不会影响 $lowbit(b)$​

那么我们只需要从低位往高位求出 $h$ 在二进制下哪些位是 1 即可

假设已经求出来答案是 $now$，需要求下一个 $lowbit$ 那就需要把当前求过的 $lowbit$ 之和减掉（即 $now$）

为了不使其为负，由 $tip3$ 可知，$\gcd(2^{60},h+2^{60}-now)=\gcd(2^{60},h-now)$，所以应该在原 $h$ 之上加上一个$2^{60}$，这对 $lowbit$ 无影响且减去 $lowbit$ 之后也不会为负​

所以每次询问 $a=2^{60},b=2^{60}-now$ 即可得到 $h$ 下一个 $lowbit$ ​在哪

如果 $g=2^{60}$ 说明已经全部找完了(因为 $h<2^{60}$)，可以退出；否则令 $now=now+g$ 即可

可以发现最高不会超过 $\lfloor \log_2 h \rfloor+2$ ​次询问，由此可见出题人还是很良心的！(~~才不会告诉你其实是出题人算错了~~)

### 总结

1. 令 $a=2^{60}$，则 $\gcd(a, x) = x$ 的最低 1 位权值（即$lowbit(x)$）。
2. 把询问包装成 $x = 2^{60} + h − now$，就能安全地减掉已拼出的部分（不为负）。
3. 每次返回的 $g$ 就是 $h$ 的“下一个”1 位，攒到 $ans$ 里，直到 $g = 2^{60}$ 结束。

## Code

```c++
#include<bits/stdc++.h>
#define ll long long
using namespace std;
void solve() {
	ll a = 1ll << 60, ans = 0;
	while(true) {
		ll b = a - ans;
		cout << "? " << a << ' ' << b << '\n';
		cout.flush();
		ll g; scanf("%lld", &g);
		if(g == a) break;
		ans += g;
	}
	cout << "! " << ans << '\n';
	cout.flush();
}
signed main() {
	int T; scanf("%d", &T);
	while(T--) {
		solve();
	}
	return 0;
}
/*
	Writer: yueyu_weihu
	Blog: prayyueyu.github.io
*/
```

