# 百度之星2023-数字串

**题目地址：**[数字串](https://www.matiji.net/exam/brushquestion/7/4347/179CE77A7B772D15A8C00DD8198AAC74?from=1)

$AC$时间：2025/6/27

## Solution

首先肯定用贪心做，选最大的长度为$n-k$的字符串

假设搜寻到$i$之前已知$[L,L+n-k-1]$是最大的

如何判断$[i,i+n-k-1]$是否比前面的大？

假设$s:[i,i+x]=s:[L,L+x]$并且$s:[i,i+x+1]!=s:[L,L+x+1]$

那么显然可以用二分去搜索这个$x$

正解：二分+$Hash$

## Code

```c++
#include<bits/stdc++.h>
#include<cmath>
#define ll long long
using namespace std;
const ll N = 4e6 + 100, mod = 998244353, INF = 1e13;
int n, k;
ll p = 1331, h[N], P[N];
string s;
ll read() {
	ll x = 0, f = 1; char ch = getchar();
	while(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}
	while(ch >= '0' && ch <= '9') {x = x * 10 + ch - '0'; ch = getchar();}
	return x * f;
}
bool check(int x, int y, int l, int r) {
	ll s1 = 0, s2 = 0;
	s1 = (h[y] - h[x - 1] * P[y - x + 1] % mod + mod) % mod;
	s2 = (h[r] - h[l - 1] * P[r - l + 1] % mod + mod) % mod;
	if(s1 == s2) return true;
	return false;
}
void Merge(int x, int l, int r) {//高精度
	string t1 = "", t2 = "", now = "", ans = " ";
	int cnt = 0;
	for(int i = l; i <= r; i++) t1 += s[i];
	while(true) {
		char c = x % 10 + '0';
		now += c;
		x /= 10;
		cnt++;
		if(!x) break;
	}
	for(int i = now.size() - 1; i >= 0; i--) t2 += now[i];
	t1 = " " + t1;
	t2 = " " + t2;
	if(t1.size() > t2.size()) swap(t1, t2);
	int len1 = t1.size() - 1, len2 = t2.size() - 1;
	int el = 0, t = len2;
	for(int i = len1; i >= 1; i--) {
		int x1 = t1[i] - '0', x2 = t2[t] - '0';
		x1 += x2 + el;
		el = x1 / 10;
		x1 %= 10;
		char c = x1 + '0';
		ans += c;
		t--;
	}
	if(len2 > len1) {
		for(int i = t; i >= 1; i--) {
			int x1 = t2[i] - '0';
			x1 += el;
			el = x1 / 10;
			x1 %= 10;
			char c = x1 + '0';
			ans += c;
		}
	}
	if(el) ans += "1";
	for(int i = ans.size() - 1; i >= 1; i--) cout << ans[i];
}
int main() {
	n = read(), k = read();
	cin >> s; s = " " + s;
	if(!k) {
		for(int i = 1; i <= n; i++) cout << s[i];
		return 0;
	}
	P[0] = 1;
	for(int i = 1; i <= n; i++) P[i] = (P[i - 1] * p) % mod;
	for(int i = 1; i <= n; i++) {
		h[i] = (h[i - 1] * p + s[i] - '0') % mod;
	}
	int L = 0, R = 0, Max = 0, len = n - k;
	for(int i = 1; i <= n; i++) {
		if(i + len - 1 > n) break;
		if(s[i] - '0' > Max) {
			Max = s[i] - '0';
			L = i;
			R = L + len - 1;
			continue;
		}
		if(s[i] - '0' < Max) continue;
		int l = 1, r = len;
		while(l < r) {
			int mid = (l + r + 1) >> 1;
			if(check(L, L + mid - 1, i, i + mid - 1)) l = mid;
			else r = mid - 1;
		}
		//s[i]~s[i+l-1]和s[L]~s[L+l-1]相同 
		if(l == len) continue;
		if(s[i + l] > s[L + l]) {
			L = i;
			R = L + len - 1;
			continue;
		}
	}
	int ans = 0;
	for(int i = 1; i <= n; i++) {
		if(i >= L && i <= R) continue;
		ans += (s[i] - '0');
	}
	Merge(ans, L, R);
	return 0;
}
//月雩·薇嫭 
```

