## **1009 Triple Inversions**

树状数组+特殊处理

算某个数$a[j]$，

$ans_2[j]=\sum_{i=1}^{j-1}(a[i]>a[j])$

$ans[j]=\sum_{i=j+1}^{n}(a[i]<a[j])$

先离散化（本题不用）

后者是树状数组基本用法，从后往前添加进树状数组，同时计算$ans[j]$

前者把$a[j]$变为$n-a[j]+1$，再从前往后添加进新的树状数组，同时计算答案即可

```c++
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=2e5+10;
ll n, ansx, ans[N], ans_2[N], tr[N], tr_2[N], a[N];
ll read(){
	ll x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
ll lowbit(ll x) {return x & (-x);}
void add(ll x, ll k) {
	while(x <= n) {
		tr[x] += k;
		x += lowbit(x);
	}
}
ll ask(ll x) {
	ll sum = 0;
	while(x) {
		sum += tr[x];
		x -= lowbit(x);
	}
	return sum;
}
void add_2(ll x, ll k) {
	while(x <= n) {
		tr_2[x] += k;
		x += lowbit(x);
	}
}
ll ask_2(ll x) {
	ll sum = 0;
	while(x) {
		sum += tr_2[x];
		x -= lowbit(x);
	}
	return sum;
}
int main(){
	n = read();
	for(ll i = 1; i <= n; i++) a[i] = read();
	for(ll i = 1; i <= n; i++) {
		ll x = n - a[i] + 1;
		add_2(x, 1);
		ans_2[i] = ask_2(x - 1);
	}
	for(ll i = n; i >= 1; i--) {
		add(a[i], 1);
		ans[i] = ask(a[i] - 1);
	} 
	for(ll i = 1; i <= n; i++) ansx += ans_2[i] * ans[i];
	cout << ansx;
	return 0;
}
```

