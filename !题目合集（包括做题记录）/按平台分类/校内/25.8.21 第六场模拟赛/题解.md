# 25.8.21 校内第六场模拟赛

实际题目为**2025内蒙古$ccpc$省赛**

## D **序列交换**

用$f_{i,j}$表示把$a_i$移动到$j(j>=i)$时序列$a_{1...j}$最小的代价

那么这样一来就很简单了

把$j$拆成两个部分，一个是$j=i$时，一个是$j>i$时

后面一个部分如果暴力求时间复杂度是$O(n^2)$肯定不行

推一下$dp$式子可以发现可以通过$O(n)$的时间复杂度预处理出来

时间复杂度降到了$O(n)$

总时间复杂度为$O(n^2)$

### Code

```c++
#include<bits/stdc++.h>
#include<cmath>
#define ll long long
#define int long long
using namespace std;
const ll N = 4e3 + 10, M = 998244353, INF = 1e14;
int n, a[N], f[N][N], sum[N];
ll read() {
	ll x = 0, f = 1; char ch = getchar();
	while(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}
	while(ch >= '0' && ch <= '9') {x = x * 10 + ch - '0'; ch = getchar();}
	return x * f;
}
signed main() {
	n = read();
	for(int i = 1; i <= n; i++) a[i] = read();
	for(int i = 1; i <= n; i++) {
		int t = abs(a[i] - a[i - 1]);
		sum[i] = sum[i - 1] + t;
	}
	for(int i = 0; i <= n + 1; i++) {
		for(int j = 0; j <= n + 1; j++) {
			f[i][j] = INF;
		}
	}
	f[1][1] = 0;
	int LasMin = 0;
	for(int i = 1; i <= n; i++) {
		for(int j = i + 1; j <= n; j++) {
			if(i != 1) {
                if[i][j] = sum[i - 1] - sum[1];
				if[i][j] += abs(a[i + 1] - a[i - 1]);
            }
			int d = abs(a[i] - a[j]);
			d += sum[j] - sum[i + 1];
			f[i][j] = min(f[i][j], LasMin);
			f[i][j] += d;
		}
		if(i == 1) {
			LasMin = abs(a[3] - a[1]);
			continue;
		}
		f[i][i] = sum[i] - sum[1];
		for(int k = 1; k <= i - 1; k++) {
			int d = abs(a[i] - a[k]);
			f[i][i] = min(f[i][i], f[k][i - 1] + d);
		}
		LasMin = INF;
		for(int j = 1; j <= i; j++) {
			LasMin = min(LasMin, f[j][i] + abs(a[i + 2] - a[j]));
		}
	}
	int ans = INF;
	for(int i = 1; i <= n; i++) ans = min(ans, f[i][n]);
	cout << ans;
	return 0;
}
//月雩·薇嫭 
```

