# 2025ICPC 南京

## K. Xiangqi

显而易见的，**车**必须在第一次移动就能吃到**象**，否则**象**能移动到任意位置，逃开**车**

判断**象**第一次移动后的位置，是否全部都能被**车**一次性吃掉，能输出“YES”，反之输出“NO”

## F. Bitwise And Path

可以发现，边权非常小，$w<2^{12}$

所以答案肯定小于$2^{12}$

那么考虑对于每个答案建图

由于只用判断连通性，所以建并查集即可

如果新增了一条边，边权$w=1010100_2$

那么对于$w1=1010100_2,w2=1010000_2,w3=1000100_2,w4=0010100_2...$的图的并查集会更新（二进制下去掉若干个$1$​），**注意剪枝，如果对于某个$w$，$u,v$已经连通了，则不需要继续往下扫**

最后查询最大值时，考虑贪心的找

假设最终答案$ans=1011_2$

那么显然对于$w=1000,w=1010,w=1011$的图，$u,v$都是连通的

即从高位往低位扫，如果对于$w=ans+2^i$的图$u,v$是连通的，显然令$ans=ans+2^i$会更优

时间复杂度不会证。

## G. Bucket Bonanza

### Solution1(G2.cpp)

考虑合并两个桶。显然令一个桶$v$越大越好，而另一个的$l$越小越好

如果合并两个以上的桶，可以发现肯定比合并两个更劣，所以任意桶最多合并一次

那么将$v$从大到小排序，将$l$从小到大排序

排序之后，假设下标为$i$，$v_i$原来属于$x$，$l_i$原来属于$y$

那么代表将$x$和$y$合并，它的贡献为$v_i-l_i*t$

用二分找到最后一个$v_{mid}-l_{mid}*t>=0$的位置，答案即为$sumv_{mid}-suml_{mid}*t$（$sum$是排序值后的前缀和）

### Solution2(G1.cpp)

考虑模拟合并过程，首先按照$t$从小到大排序

对于两个桶$x$和$y$，如果$v_x-l_x\cdot t+v_y-l_y\cdot t<max(v_x,v_y)-min(l_x,l_y)\cdot t$，那么显然需要合并

假设$v_x>v_y,l_x>l_y$，那么可以写成$v_y<l_x\cdot t$，所以令$v$尽量小，而$l$尽量大的两个桶可以合并

用两个优先队列，一个按照$v$从小到大保存，一个按照$l$​从大到小保存

每次取堆顶（**需要保证该桶未被遗弃**），判断是否满足合并条件（上述公式），如果满足：

1. 堆顶编号相同，说明这个桶可以被遗弃，已经漏完了
2. 编号不同，那么将这两个桶合并**并遗弃**

在模拟过程中，用第三个优先队列来记录哪些桶在当前$t$下是还有剩余的，以$v/l$从小到大排序

每次计算答案前，遍历第三个队列，**遗弃掉所有已经漏完的桶**