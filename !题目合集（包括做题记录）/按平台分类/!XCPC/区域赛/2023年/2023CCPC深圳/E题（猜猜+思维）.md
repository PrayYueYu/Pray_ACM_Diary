# [二合一](https://cpc.csgrandeur.cn/csgoj/problemset/problem?pid=1241)

## Description

这是一道二合一题。

给定一个长度为 n 的颜色序列 c1,⋯,cn(1≤ci≤n)。

对于 $1\leq x\leq n,1\leq l\leq r\leq n$，定义 occ(x,l,r) 为颜色 x 在序列 c 的第 l 至 r 项出现的次数。

你需要找到序列的一个区间 [l,r]，再找到两种颜色 x,y（注意 x,y 可以相等），使得$occ(x,l,r)\ or\ ⁡occ(y,l,r)$最大，其中 or 为二进制按位或。你只需要输出这个最大值。

## Input

**本题有多组测试数据**。第一行一个正整数 T（1≤T≤105） 表示数据组数。对于每组数据，

- 第一行一个正整数 n（1≤n≤105），
- 第二行 n 个整数 c1,⋯,cn 描述序列 c（1≤ci≤n）。

保证所有数据中 n 的和不超过 5×105。

## Output

对于每组数据输出一行一个整数表示答案。

## Solution

典型的猜猜题

先找到数量最多的两个颜色$A$和$B$，假设它们的数量分别为$c_A$和$c_B$

那么显然$Ans \le max(a|b)$其中$a \in [0,c_A], b \in [0,c_B]$

那么怎么快速的求$a|b$的最大值呢？

假设$c_A=100010100,c_B=001010010$（共9位，从左到右是第1,2,3...位）

那么假设某一位上$c_A$和$c_B$都是$1$，那么考虑这样的最高位，即为第5位

假设慢慢缩小范围，且一直保证$a>=100010000,b>=000010000$

**对于第1~4位，数值大小一定不会变，且只有两种情况 **

①一个为1，一个为0。这种情况下$OR$之后必定为1，也必定不用把0更改为1

②两个都为0。这种情况下如果把某个0改为1，那么必定使得前面某一位1变成0

因为不可能出现两位都是1的情况

比如对于第二位，$c_A$是0，$c_B$是0，假如想使得$c_A$第二位变成1那么必定会把$c_A$的第一位变成0，那么久得不偿失，因为第一位上就全是0，$OR$之后也为0，就变小了

**所以假设第$x$位上$c_A$，$c_B$都是1且$x$是最小的满足这个条件的数（最高位），那么对于$1~x-1$位上的值不需要改变**

**对于5~最后一位**

必定存在某一个区间使得$a=100010000,b>=10000$或者$a>=100010000,b=1010000$

那么再在这个基础上缩小区间，必定能使得$a=100001111,b>=10000$或者$a>=100010000,b=1001111$

那么此时对于$5$~最后一位而言，最大值的情况下$OR$之后必定全是1

并且这种情况下也不会对第5位之前有影响

所以最大值即为：

$Ans=c_A|c_B|p$

其中：$p=2^{log2(c_A \& c_B)}-1$

（可以代回例子看看）

## Code

```c++
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const ll N = 1e5 + 10, M = 1e6 + 9;
int n, a[N], num[N];
ll read() {
	ll x = 0, f = 1; char ch = getchar();
	while(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}
	while(ch >= '0' && ch <= '9') {x = x * 10 + ch - '0'; ch = getchar();}
	return x * f;
}
int main() {
    int T = read();
    while(T--) {
    	n = read();
    	for(int i = 1; i <= n; i++) {
    		int x = read();
    		num[x]++;
		}
		int c1 = 0, c2 = 0;
    	for(int i = 1; i <= n; i++) {
    		if(num[i] > c1) {
    			c2 = c1;
    			c1 = num[i];
			}
			else if(num[i] > c2) c2 = num[i];
		}
		if(!c2)cout << c1 << endl;//注意特判！如果只有一个颜色则需要特判
		else {
			int cx = (int)log2(c1 & c2); 
			cx = (1 << (cx + 1)) - 1;
			if(!(c1 & c2)) cx = 0;
            //如果c1 & c2为0那么cx会计算为负无穷，则需特判
			cout << ((c1 | c2) | cx) << endl;
		}
		for(int i = 1; i <= n; i++) num[i] = 0; 
	}
    return 0;
}
```

