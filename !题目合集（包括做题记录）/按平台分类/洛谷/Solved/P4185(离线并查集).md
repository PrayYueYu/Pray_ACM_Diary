# P4185 [USACO18JAN] MooTube G

**题目地址：**[P4185 [USACO18JAN] MooTube G](https://www.luogu.com.cn/problem/P4185)

## Solution

很显然的可以发现，如果常规离线，记录每一个状态，那么空间复杂度会爆，而如果在线做时间复杂度会爆

所以肯定有什么优良的特性

考虑一下如果求的是$K=k_i$的时候，整个图该怎么划分

那么显然可以由$K=k_i+1$划分的区域得到

在$K=k_i+1$的基础上，把路径长度为$k_i$的路径的两端合并为一个并查集

所以对于询问，我们按照$k$从大到小排序

那么该怎么寻找符合条件的路径长度？如果正常查找必定超时

所以我们把路径也按照路径长度$r$从大到小排序，已经选取过的；路径不会再选择

时间复杂度$O(n(1+log_n)+q(l+log_q))=O(nlog_n)$

## Code

```c++
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const ll N = 2e6 + 100, M = 998244353, INF = 1e9 + 10, Nx = 1e5;
int n, q, fa[N], ans[N], num[N];
ll read() {
	ll x = 0, f = 1; char ch = getchar();
	while(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}
	while(ch >= '0' && ch <= '9') {x = x * 10 + ch - '0'; ch = getchar();}
	return x * f;
}
struct Path {
	int u, v, k;
} s[N];
struct Ask {
	int k, v, id;
} a[N];
bool cmp1(Path x, Path y) {return x.k > y.k;}
bool cmp2(Ask x, Ask y) {return x.k > y.k;}
int GetF(int x) {return x == fa[x]? x: fa[x] = GetF(fa[x]);}
int main() {
	n = read(); q = read();
	for(int i = 1; i < n; i++) {
		s[i].u = read(), s[i].v = read();
		s[i].k = read();
	}
	for(int i = 1; i <= q; i++) {
		a[i].k = read();
		a[i].v = read();
		a[i].id = i;
	}
	sort(s + 1, s + n, cmp1);
	sort(a + 1, a + q + 1, cmp2);
	for(int i = 1; i <= n; i++) fa[i] = i, num[i] = 1;
	int now = 1;
	for(int i = 1; i <= q; i++) {
		while(true) {
			if(s[now].k < a[i].k) break;
			int u = s[now].u, v = s[now].v;
			int Fau = GetF(u), Fav = GetF(v);
			if(Fau != Fav) {
				fa[Fau] = Fav;
				num[Fav] += num[Fau];
			}
			now++;
			if(now == n) break;
		}
		int Fa = GetF(a[i].v);
		ans[a[i].id] = num[Fa] - 1;
	}
	for(int i = 1; i <= q; i++) {
		printf("%d\n", ans[i]);
	}
	return 0;
}
```

